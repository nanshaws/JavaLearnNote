{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{341:function(t,a,e){\"use strict\";e.r(a);var n=e(14),r=Object(n.a)({},(function(){var t=this,a=t._self._c;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"java17新特性\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#java17新特性\"}},[t._v(\"#\")]),t._v(\" java17新特性\")]),t._v(\" \"),a(\"ul\",[a(\"li\",[t._v(\"Improvements in Random Number Generator algorithms\")]),t._v(\" \"),a(\"li\",[t._v(\"Deserialization filtering\")]),t._v(\" \"),a(\"li\",[t._v(\"Modified switch case\")]),t._v(\" \"),a(\"li\",[t._v(\"Reflection API for a sealed class\")]),t._v(\" \"),a(\"li\",[t._v(\"Vector API\")])]),t._v(\" \"),a(\"p\",[t._v(\"中文介绍：\")]),t._v(\" \"),a(\"ol\",[a(\"li\",[t._v(\"随机数生成器算法的改进：在Java 17中，对随机数生成器算法进行了一些改进，以提高性能和减少内存占用。这些改进包括使用更高效的算法和优化了随机数生成器的实现。\")]),t._v(\" \"),a(\"li\",[t._v(\"反序列化过滤：在Java 17中，引入了一个新的特性，允许在反序列化过程中进行过滤操作。这可以防止恶意代码执行或处理不安全的输入数据。\")]),t._v(\" \"),a(\"li\",[t._v(\"修改后的switch case语法：在Java 17中，对switch case语法进行了一些修改，以提供更好的类型安全性和代码可读性。现在可以使用新的switch表达式来简化代码。\")]),t._v(\" \"),a(\"li\",[t._v(\"密封类的反射API：在Java 17中，引入了一个新的反射API，用于支持密封类。密封类是一种限制继承的类，通过反射API可以访问密封类的成员和方法。\")]),t._v(\" \"),a(\"li\",[t._v(\"Vector API：在Java 17中，引入了一个新的Vector API，提供了更灵活和高效的方式来处理向量计算。这个API包括了一些新的方法，如add、subtract、multiply等。\")])]),t._v(\" \"),a(\"h2\",{attrs:{id:\"improvements-in-random-number-generator-algorithms-modified-switch-case\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#improvements-in-random-number-generator-algorithms-modified-switch-case\"}},[t._v(\"#\")]),t._v(\" Improvements in Random Number Generator algorithms+Modified switch case\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('import java.util.Random;\\nimport java.util.Vector;\\n\\npublic class Java17Example {\\n    public static void main(String[] args) {\\n        // 使用改进的随机数生成器算法\\n        Random random = new Random();\\n        int randomNumber = random.nextInt(10);\\n        System.out.println(\"Random number: \" + randomNumber);\\n\\n        // 使用修改后的switch case语法\\n        int day = 3;\\n        String dayName = switch (day) {\\n            case 1 -> \"Monday\";\\n            case 2 -> \"Tuesday\";\\n            case 3 -> \"Wednesday\";\\n            case 4 -> \"Thursday\";\\n            case 5 -> \"Friday\";\\n            case 6 -> \"Saturday\";\\n            case 7 -> \"Sunday\";\\n            default -> \"Invalid day\";\\n        };\\n        System.out.println(\"Day name: \" + dayName);\\n    }\\n}\\n')])])]),a(\"h2\",{attrs:{id:\"deserialization-filtering\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#deserialization-filtering\"}},[t._v(\"#\")]),t._v(\" Deserialization filtering\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('import java.io.*;\\n\\npublic class DeserializationFilterExample {\\n    public static void main(String[] args) {\\n        // 创建一个包含恶意代码的序列化对象\\n        byte[] serializedObject = createSerializedObject();\\n\\n        // 使用反序列化过滤器进行反序列化\\n        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializedObject);\\n             ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream)) {\\n            objectInputStream.setObjectInputFilter(new ObjectInputFilter() {\\n                @Override\\n                public Status checkInput(FilterInfo filterInfo) {\\n                    if (filterInfo.references() > 0) {\\n                        return Status.REJECTED; // 拒绝包含引用的对象\\n                    } else {\\n                        return Status.ALLOWED; // 允许其他对象\\n                    }\\n                }\\n            });\\n\\n            Object deserializedObject = objectInputStream.readObject();\\n            System.out.println(\"Deserialized object: \" + deserializedObject);\\n        } catch (IOException | ClassNotFoundException e) {\\n            e.printStackTrace();\\n        }\\n    }\\n\\n    private static byte[] createSerializedObject() {\\n        // 创建包含恶意代码的序列化对象\\n        // 示例省略\\n        return null;\\n    }\\n}\\n')])])]),a(\"p\",[t._v(\"​        在这个例子中，我们首先创建了一个包含恶意代码的序列化对象。然后，我们使用\"),a(\"code\",[t._v(\"ObjectInputStream\")]),t._v(\"进行反序列化，并设置了一个自定义的反序列化过滤器。在过滤器中，我们检查对象的引用数量，如果大于0，则拒绝该对象；否则，允许其他对象。通过这种方式，我们可以防止恶意代码执行或处理不安全的输入数据。\")]),t._v(\" \"),a(\"h2\",{attrs:{id:\"reflection-api-for-a-sealed-class\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflection-api-for-a-sealed-class\"}},[t._v(\"#\")]),t._v(\" Reflection API for a sealed class\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('import java.lang.reflect.Method;\\n\\npublic class SealedClassReflectionExample {\\n    public static void main(String[] args) {\\n        // 获取密封类的方法\\n        Method sealedMethod = getSealedMethod();\\n\\n        // 调用密封类的方法\\n        try {\\n            Object result = sealedMethod.invoke(null);\\n            System.out.println(\"Result: \" + result);\\n        } catch (Exception e) {\\n            e.printStackTrace();\\n        }\\n    }\\n\\n    private static Method getSealedMethod() {\\n        // 获取密封类的方法\\n        // 示例省略\\n        return null;\\n    }\\n}\\n')])])]),a(\"h2\",{attrs:{id:\"vector-api\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vector-api\"}},[t._v(\"#\")]),t._v(\" Vector API\")]),t._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[t._v('package org.cyl.spaceutils;\\n \\nimport jdk.incubator.vector.FloatVector;\\nimport jdk.incubator.vector.VectorSpecies;\\n \\npublic class VectorScalarOperations {\\n    public static void main(String[] args) {\\n        // 定义矢量a和b\\n        float[] a = {1, 2, 3};\\n        float[] b = {4, 5, 6};\\n        float[] c=new float[a.length];\\n        VectorScalarOperations v1=new VectorScalarOperations();\\n        long startTime = System.nanoTime();\\n        v1.vectorComputation(a,b,c);\\n        long endTime = System.nanoTime();\\n        System.out.println(\"矢量花费的时间:\"+(endTime-startTime));\\n \\n        long startTime1 = System.nanoTime();\\n        v1.xadd(a,b,c);\\n        long endTime1 = System.nanoTime();\\n        System.out.println(\"标量花费的时间:\"+(endTime1-startTime1));\\n \\n    }\\n \\n    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_PREFERRED;\\n    void vectorComputation(float[] a, float[] b, float[] c) {\\n        int i = 0;\\n        int upperBound = SPECIES.loopBound(a.length);\\n        for (; i < upperBound; i += SPECIES.length()) {\\n            // FloatVector va, vb, vc;\\n            var va = FloatVector.fromArray(SPECIES, a, i);\\n            var vb = FloatVector.fromArray(SPECIES, b, i);\\n            var vc = va.mul(va)\\n                    .add(vb.mul(vb));\\n            vc.intoArray(c, i);\\n        }\\n    }\\n \\n    void xadd(float[]a,float[]b,float[]c){\\n        for (int i=0;i<a.length;i++){\\n            c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;\\n        }\\n    }\\n}\\n')])])])])}),[],!1,null,null,null);a.default=r.exports}}]);","extractedComments":[]}