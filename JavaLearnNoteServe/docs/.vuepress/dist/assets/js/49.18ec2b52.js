(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{372:function(t,a,e){"use strict";e.r(a);var n=e(14),r=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"java17新特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java17新特性"}},[t._v("#")]),t._v(" java17新特性")]),t._v(" "),a("ul",[a("li",[t._v("Improvements in Random Number Generator algorithms")]),t._v(" "),a("li",[t._v("Deserialization filtering")]),t._v(" "),a("li",[t._v("Modified switch case")]),t._v(" "),a("li",[t._v("Reflection API for a sealed class")]),t._v(" "),a("li",[t._v("Vector API")])]),t._v(" "),a("p",[t._v("中文介绍：")]),t._v(" "),a("ol",[a("li",[t._v("随机数生成器算法的改进：在Java 17中，对随机数生成器算法进行了一些改进，以提高性能和减少内存占用。这些改进包括使用更高效的算法和优化了随机数生成器的实现。")]),t._v(" "),a("li",[t._v("反序列化过滤：在Java 17中，引入了一个新的特性，允许在反序列化过程中进行过滤操作。这可以防止恶意代码执行或处理不安全的输入数据。")]),t._v(" "),a("li",[t._v("修改后的switch case语法：在Java 17中，对switch case语法进行了一些修改，以提供更好的类型安全性和代码可读性。现在可以使用新的switch表达式来简化代码。")]),t._v(" "),a("li",[t._v("密封类的反射API：在Java 17中，引入了一个新的反射API，用于支持密封类。密封类是一种限制继承的类，通过反射API可以访问密封类的成员和方法。")]),t._v(" "),a("li",[t._v("Vector API：在Java 17中，引入了一个新的Vector API，提供了更灵活和高效的方式来处理向量计算。这个API包括了一些新的方法，如add、subtract、multiply等。")])]),t._v(" "),a("h2",{attrs:{id:"improvements-in-random-number-generator-algorithms-modified-switch-case"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#improvements-in-random-number-generator-algorithms-modified-switch-case"}},[t._v("#")]),t._v(" Improvements in Random Number Generator algorithms+Modified switch case")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import java.util.Random;\nimport java.util.Vector;\n\npublic class Java17Example {\n    public static void main(String[] args) {\n        // 使用改进的随机数生成器算法\n        Random random = new Random();\n        int randomNumber = random.nextInt(10);\n        System.out.println("Random number: " + randomNumber);\n\n        // 使用修改后的switch case语法\n        int day = 3;\n        String dayName = switch (day) {\n            case 1 -> "Monday";\n            case 2 -> "Tuesday";\n            case 3 -> "Wednesday";\n            case 4 -> "Thursday";\n            case 5 -> "Friday";\n            case 6 -> "Saturday";\n            case 7 -> "Sunday";\n            default -> "Invalid day";\n        };\n        System.out.println("Day name: " + dayName);\n    }\n}\n')])])]),a("h2",{attrs:{id:"deserialization-filtering"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deserialization-filtering"}},[t._v("#")]),t._v(" Deserialization filtering")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import java.io.*;\n\npublic class DeserializationFilterExample {\n    public static void main(String[] args) {\n        // 创建一个包含恶意代码的序列化对象\n        byte[] serializedObject = createSerializedObject();\n\n        // 使用反序列化过滤器进行反序列化\n        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(serializedObject);\n             ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream)) {\n            objectInputStream.setObjectInputFilter(new ObjectInputFilter() {\n                @Override\n                public Status checkInput(FilterInfo filterInfo) {\n                    if (filterInfo.references() > 0) {\n                        return Status.REJECTED; // 拒绝包含引用的对象\n                    } else {\n                        return Status.ALLOWED; // 允许其他对象\n                    }\n                }\n            });\n\n            Object deserializedObject = objectInputStream.readObject();\n            System.out.println("Deserialized object: " + deserializedObject);\n        } catch (IOException | ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static byte[] createSerializedObject() {\n        // 创建包含恶意代码的序列化对象\n        // 示例省略\n        return null;\n    }\n}\n')])])]),a("p",[t._v("​        在这个例子中，我们首先创建了一个包含恶意代码的序列化对象。然后，我们使用"),a("code",[t._v("ObjectInputStream")]),t._v("进行反序列化，并设置了一个自定义的反序列化过滤器。在过滤器中，我们检查对象的引用数量，如果大于0，则拒绝该对象；否则，允许其他对象。通过这种方式，我们可以防止恶意代码执行或处理不安全的输入数据。")]),t._v(" "),a("h2",{attrs:{id:"reflection-api-for-a-sealed-class"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reflection-api-for-a-sealed-class"}},[t._v("#")]),t._v(" Reflection API for a sealed class")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('import java.lang.reflect.Method;\n\npublic class SealedClassReflectionExample {\n    public static void main(String[] args) {\n        // 获取密封类的方法\n        Method sealedMethod = getSealedMethod();\n\n        // 调用密封类的方法\n        try {\n            Object result = sealedMethod.invoke(null);\n            System.out.println("Result: " + result);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static Method getSealedMethod() {\n        // 获取密封类的方法\n        // 示例省略\n        return null;\n    }\n}\n')])])]),a("h2",{attrs:{id:"vector-api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vector-api"}},[t._v("#")]),t._v(" Vector API")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('package org.cyl.spaceutils;\n \nimport jdk.incubator.vector.FloatVector;\nimport jdk.incubator.vector.VectorSpecies;\n \npublic class VectorScalarOperations {\n    public static void main(String[] args) {\n        // 定义矢量a和b\n        float[] a = {1, 2, 3};\n        float[] b = {4, 5, 6};\n        float[] c=new float[a.length];\n        VectorScalarOperations v1=new VectorScalarOperations();\n        long startTime = System.nanoTime();\n        v1.vectorComputation(a,b,c);\n        long endTime = System.nanoTime();\n        System.out.println("矢量花费的时间:"+(endTime-startTime));\n \n        long startTime1 = System.nanoTime();\n        v1.xadd(a,b,c);\n        long endTime1 = System.nanoTime();\n        System.out.println("标量花费的时间:"+(endTime1-startTime1));\n \n    }\n \n    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_PREFERRED;\n    void vectorComputation(float[] a, float[] b, float[] c) {\n        int i = 0;\n        int upperBound = SPECIES.loopBound(a.length);\n        for (; i < upperBound; i += SPECIES.length()) {\n            // FloatVector va, vb, vc;\n            var va = FloatVector.fromArray(SPECIES, a, i);\n            var vb = FloatVector.fromArray(SPECIES, b, i);\n            var vc = va.mul(va)\n                    .add(vb.mul(vb));\n            vc.intoArray(c, i);\n        }\n    }\n \n    void xadd(float[]a,float[]b,float[]c){\n        for (int i=0;i<a.length;i++){\n            c[i] = (a[i] * a[i] + b[i] * b[i]) * -1.0f;\n        }\n    }\n}\n')])])])])}),[],!1,null,null,null);a.default=r.exports}}]);